package cse.ucdenver.csci5593.parser;

import cse.ucdenver.csci5593.instruction.Instruction;

import java.io.*;
import java.util.*;

/**
 * Created by willi on 3/14/2016.
 */
public class Parser {

    private InstructionSet instSet;

    // Hold the map between memory address and variable name
    private HashMap<String, Integer> map;
    // Hold the used memory addresses so we don't accidentally
    // use the same slot twice. Index 0 is reserved for constants.
    // 1-8 is reserved for general purpose registers
    private int next;

    public Parser(InstructionSet instructionSet) {
        this.instSet = instructionSet;
        this.map = new HashMap<>();
        this.next = this.instSet.maxRegisterIndex();
    }

    /**
     * Parses a given file and returns a list of instructions
     * that can be used by a Core object to run
     *
     * @param filename
     * @return List of instructions generated by the file
     *         or null if the file isn't properly formatted
     * @see cse.ucdenver.csci5593.core.Core
     */
    public Queue<Instruction> parseFile(String filename) {
        // Result
        Queue<Instruction> result = new ArrayDeque<>();

        // Loop through the file
        try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {
            String line;
            while ((line = reader.readLine()) != null) {

                // Split the line at the spaces
                String[] splitLine = this.instSet.stripComments(line).split(" ");

                // Create new instruction list
                List<Instruction> instructions = this.instSet.generateInstructions(splitLine);

                // Add instructions to set
                result.addAll(instructions);
            }
        } catch (FileNotFoundException e) {
            System.err.print("Parse file not found: " + filename);
        } catch (IOException e) {
            System.err.print("Error reading parse file: " + e);
        }

        return null;
    }
}
